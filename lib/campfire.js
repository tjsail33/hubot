// Generated by CoffeeScript 1.6.3
(function() {
  var Adapter, Campfire, CampfireStreaming, EnterMessage, EventEmitter, HTTPS, LeaveMessage, Robot, TextMessage, TopicMessage, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  HTTPS = require('https');

  EventEmitter = require('events').EventEmitter;

  Robot = require('../robot');

  Adapter = require('../adapter');

  _ref = require('../message'), TextMessage = _ref.TextMessage, EnterMessage = _ref.EnterMessage, LeaveMessage = _ref.LeaveMessage, TopicMessage = _ref.TopicMessage;

  Campfire = (function(_super) {
    __extends(Campfire, _super);

    function Campfire() {
      _ref1 = Campfire.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Campfire.prototype.send = function() {
      var envelope, string, strings,
        _this = this;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (strings.length > 0) {
        string = strings.shift();
        if (typeof string === 'function') {
          string();
          return this.send.apply(this, [envelope].concat(__slice.call(strings)));
        } else {
          return this.bot.Room(envelope.room).speak(string, function(err, data) {
            if (err != null) {
              _this.robot.logger.error("Campfire send error: " + err);
            }
            return _this.send.apply(_this, [envelope].concat(__slice.call(strings)));
          });
        }
      }
    };

    Campfire.prototype.emote = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.send.apply(this, [envelope].concat(__slice.call(strings.map(function(str) {
        return "*" + str + "*";
      }))));
    };

    Campfire.prototype.reply = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.send.apply(this, [envelope].concat(__slice.call(strings.map(function(str) {
        return "" + envelope.user.name + ": " + str;
      }))));
    };

    Campfire.prototype.topic = function() {
      var envelope, strings,
        _this = this;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.bot.Room(envelope.room).topic(strings.join(" / "), function(err, data) {
        if (err != null) {
          return _this.robot.logger.error("Campfire topic error: " + err);
        }
      });
    };

    Campfire.prototype.play = function() {
      var envelope, strings,
        _this = this;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.bot.Room(envelope.room).sound(strings.shift(), function(err, data) {
        if (err != null) {
          _this.robot.logger.error("Campfire sound error: " + err);
        }
        return _this.play.apply(_this, [envelope].concat(__slice.call(strings)));
      });
    };

    Campfire.prototype.locked = function() {
      var envelope, strings,
        _this = this;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (envelope.message["private"]) {
        return this.send.apply(this, [envelope].concat(__slice.call(strings)));
      } else {
        return this.bot.Room(envelope.room).lock(function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          strings.push(function() {
            return setTimeout((function() {
              return _this.bot.Room(envelope.room).unlock();
            }), 3000);
          });
          return _this.send.apply(_this, [envelope].concat(__slice.call(strings)));
        });
      }
    };

    Campfire.prototype.run = function() {
      var bot, options, self, withAuthor;
      self = this;
      options = {
        token: process.env.HUBOT_CAMPFIRE_TOKEN,
        rooms: process.env.HUBOT_CAMPFIRE_ROOMS,
        account: process.env.HUBOT_CAMPFIRE_ACCOUNT
      };
      bot = new CampfireStreaming(options, this.robot);
      withAuthor = function(callback) {
        return function(id, created, room, user, body) {
          return bot.User(user, function(err, userData) {
            var author, userId;
            if (userData.user) {
              author = self.robot.brain.userForId(userData.user.id, userData.user);
              userId = userData.user.id;
              self.robot.brain.data.users[userId].name = userData.user.name;
              self.robot.brain.data.users[userId].email_address = userData.user.email_address;
              author.room = room;
              return callback(id, created, room, user, body, author);
            }
          });
        };
      };
      bot.on("TextMessage", withAuthor(function(id, created, room, user, body, author) {
        var message;
        if (bot.info.id !== author.id) {
          message = new TextMessage(author, body, id);
          message["private"] = bot["private"][room];
          return self.receive(message);
        }
      }));
      bot.on("EnterMessage", withAuthor(function(id, created, room, user, body, author) {
        if (bot.info.id !== author.id) {
          return self.receive(new EnterMessage(author, null, id));
        }
      }));
      bot.on("LeaveMessage", withAuthor(function(id, created, room, user, body, author) {
        if (bot.info.id !== author.id) {
          return self.receive(new LeaveMessage(author, null, id));
        }
      }));
      bot.on("TopicChangeMessage", withAuthor(function(id, created, room, user, body, author) {
        if (bot.info.id !== author.id) {
          return self.receive(new TopicMessage(author, body, id));
        }
      }));
      bot.on("LockMessage", withAuthor(function(id, created, room, user, body, author) {
        return bot["private"][room] = true;
      }));
      bot.on("UnlockMessage", withAuthor(function(id, created, room, user, body, author) {
        return bot["private"][room] = false;
      }));
      bot.Me(function(err, data) {
        var roomId, _i, _len, _ref2, _results;
        bot.info = data.user;
        bot.name = bot.info.name;
        _ref2 = bot.rooms;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          roomId = _ref2[_i];
          _results.push((function(roomId) {
            return bot.Room(roomId).join(function(err, callback) {
              return bot.Room(roomId).listen();
            });
          })(roomId));
        }
        return _results;
      });
      bot.on("reconnect", function(roomId) {
        return bot.Room(roomId).join(function(err, callback) {
          return bot.Room(roomId).listen();
        });
      });
      this.bot = bot;
      return self.emit("connected");
    };

    return Campfire;

  })(Adapter);

  exports.use = function(robot) {
    return new Campfire(robot);
  };

  CampfireStreaming = (function(_super) {
    __extends(CampfireStreaming, _super);

    function CampfireStreaming(options, robot) {
      this.robot = robot;
      if (!((options.token != null) && (options.rooms != null) && (options.account != null))) {
        this.robot.logger.error("Not enough parameters provided. I need a token, rooms and account");
        process.exit(1);
      }
      this.token = options.token;
      this.rooms = options.rooms.split(",");
      this.account = options.account;
      this.host = this.account + ".campfirenow.com";
      this.authorization = "Basic " + new Buffer("" + this.token + ":x").toString("base64");
      this["private"] = {};
    }

    CampfireStreaming.prototype.Rooms = function(callback) {
      return this.get("/rooms", callback);
    };

    CampfireStreaming.prototype.User = function(id, callback) {
      return this.get("/users/" + id, callback);
    };

    CampfireStreaming.prototype.Me = function(callback) {
      return this.get("/users/me", callback);
    };

    CampfireStreaming.prototype.Room = function(id) {
      var logger, self;
      self = this;
      logger = this.robot.logger;
      return {
        show: function(callback) {
          return self.get("/room/" + id, callback);
        },
        join: function(callback) {
          return self.post("/room/" + id + "/join", "", callback);
        },
        leave: function(callback) {
          return self.post("/room/" + id + "/leave", "", callback);
        },
        lock: function(callback) {
          return self.post("/room/" + id + "/lock", "", callback);
        },
        unlock: function(callback) {
          return self.post("/room/" + id + "/unlock", "", callback);
        },
        paste: function(text, callback) {
          return this.message(text, "PasteMessage", callback);
        },
        topic: function(text, callback) {
          var body;
          body = {
            room: {
              topic: text
            }
          };
          return self.put("/room/" + id, body, callback);
        },
        sound: function(text, callback) {
          return this.message(text, "SoundMessage", callback);
        },
        speak: function(text, callback) {
          var body;
          body = {
            message: {
              "body": text
            }
          };
          return self.post("/room/" + id + "/speak", body, callback);
        },
        message: function(text, type, callback) {
          var body;
          body = {
            message: {
              "body": text,
              "type": type
            }
          };
          return self.post("/room/" + id + "/speak", body, callback);
        },
        listen: function() {
          var headers, options, request, _ref2, _ref3;
          headers = {
            "Host": "streaming.campfirenow.com",
            "Authorization": self.authorization,
            "User-Agent": "Hubot/" + ((_ref2 = this.robot) != null ? _ref2.version : void 0) + " (" + ((_ref3 = this.robot) != null ? _ref3.name : void 0) + ")"
          };
          options = {
            "agent": false,
            "host": "streaming.campfirenow.com",
            "port": 443,
            "path": "/room/" + id + "/live.json",
            "method": "GET",
            "headers": headers
          };
          request = HTTPS.request(options, function(response) {
            var buf;
            response.setEncoding("utf8");
            buf = '';
            response.on("data", function(chunk) {
              var data, error, offset, part, _results;
              if (chunk === ' ') {

              } else if (chunk.match(/^\s*Access Denied/)) {
                return logger.error("Campfire error on room " + id + ": " + chunk);
              } else {
                buf += chunk;
                _results = [];
                while ((offset = buf.indexOf("\r")) > -1) {
                  part = buf.substr(0, offset);
                  buf = buf.substr(offset + 1);
                  if (part) {
                    try {
                      data = JSON.parse(part);
                      _results.push(self.emit(data.type, data.id, data.created_at, data.room_id, data.user_id, data.body));
                    } catch (_error) {
                      error = _error;
                      _results.push(logger.error("Campfire data error: " + error + "\n" + error.stack));
                    }
                  } else {
                    _results.push(void 0);
                  }
                }
                return _results;
              }
            });
            response.on("end", function() {
              logger.error("Streaming connection closed for room " + id + ". :(");
              return setTimeout(function() {
                return self.emit("reconnect", id);
              }, 5000);
            });
            return response.on("error", function(err) {
              return logger.error("Campfire listen response error: " + err);
            });
          });
          request.on("error", function(err) {
            return logger.error("Campfire listen request error: " + err);
          });
          return request.end();
        }
      };
    };

    CampfireStreaming.prototype.get = function(path, callback) {
      return this.request("GET", path, null, callback);
    };

    CampfireStreaming.prototype.post = function(path, body, callback) {
      return this.request("POST", path, body, callback);
    };

    CampfireStreaming.prototype.put = function(path, body, callback) {
      return this.request("PUT", path, body, callback);
    };

    CampfireStreaming.prototype.request = function(method, path, body, callback) {
      var headers, logger, options, request, _ref2, _ref3;
      logger = this.robot.logger;
      headers = {
        "Authorization": this.authorization,
        "Host": this.host,
        "Content-Type": "application/json",
        "User-Agent": "Hubot/" + ((_ref2 = this.robot) != null ? _ref2.version : void 0) + " (" + ((_ref3 = this.robot) != null ? _ref3.name : void 0) + ")"
      };
      options = {
        "agent": false,
        "host": this.host,
        "port": 443,
        "path": path,
        "method": method,
        "headers": headers
      };
      if (method === "POST" || method === "PUT") {
        if (typeof body !== "string") {
          body = JSON.stringify(body);
        }
        body = new Buffer(body);
        options.headers["Content-Length"] = body.length;
      }
      request = HTTPS.request(options, function(response) {
        var data;
        data = "";
        response.on("data", function(chunk) {
          return data += chunk;
        });
        response.on("end", function() {
          var error;
          if (response.statusCode >= 400) {
            switch (response.statusCode) {
              case 401:
                throw new Error("Invalid access token provided");
                break;
              default:
                logger.error("Campfire HTTPS status code: " + response.statusCode);
                logger.error("Campfire HTTPS response data: " + data);
            }
          }
          if (callback) {
            try {
              return callback(null, JSON.parse(data));
            } catch (_error) {
              error = _error;
              return callback(null, data || {});
            }
          }
        });
        return response.on("error", function(err) {
          logger.error("Campfire HTTPS response error: " + err);
          return callback(err, {});
        });
      });
      if (method === "POST" || method === "PUT") {
        request.end(body, 'binary');
      } else {
        request.end();
      }
      return request.on("error", function(err) {
        return logger.error("Campfire request error: " + err);
      });
    };

    return CampfireStreaming;

  })(EventEmitter);

}).call(this);
